        public T[] FullChoice(T[] B, T[] X)
        {
            T aux, maximum, module, ratio;
            int row, column;
            T[] result = new T[matrixSize];
            int[] index_var = new int[matrixSize];
            int aux2;

            for (int i = 0; i < matrixSize; i++)
                index_var[i] = i;

            for (int n = 0; n < matrixSize - 1; n++)
            {
                row = n;
                column = n;
                if (typeof(T) == typeof(float))
                {
                    maximum = (T)Convert.ChangeType((float)(object)Math.Abs((float)(object)matrixNumbers[n, n]), typeof(T));
                    for (int i = n; i < matrixSize; i++)
                    {
                        for (int j = n; j < matrixSize; j++)
                        {
                            module = (T)Convert.ChangeType((float)(object)Math.Abs((float)(object)matrixNumbers[i, j]), typeof(T));
                            if ((float)(object)maximum < (float)(object)module)
                            {
                                maximum = module;
                                row = i;
                                column = j;
                            }
                        }
                    }
                }
                if (typeof(T) == typeof(double))
                {
                    maximum = (T)Convert.ChangeType((double)(object)Math.Abs((double)(object)matrixNumbers[n, n]), typeof(T));
                    for (int i = n; i < matrixSize; i++)
                    {
                        for (int j = n; j < matrixSize; j++)
                        {
                            module = (T)Convert.ChangeType((double)(object)Math.Abs((double)(object)matrixNumbers[i, j]), typeof(T));
                            if ((double)(object)maximum < (double)(object)module)
                            {
                                maximum = module;
                                row = i;
                                column = j;
                            }
                        }
                    }
                }
                if (row != n)
                {
                    Change_row(n, row, n);
                    aux = B[n];
                    B[n] = B[row];
                    B[row] = aux;
                }

                if (column != n)
                {
                    Change_column(n, column);
                    aux2 = index_var[n];//(T)Convert.ChangeType(index_var[n], typeof(T));
                    index_var[n] = index_var[column];
                    index_var[column] = aux2;
                }

                // wykonujemy zerowanie wszystkich rowy poniżej n-tego
                for (int i = n + 1; i < matrixSize; i++)
                {
                    if (typeof(T) == typeof(float))
                    {
                        ratio = (T)Convert.ChangeType((float)(object)matrixNumbers[i, n] / (float)(object)matrixNumbers[n, n], typeof(T));
                        for (int j = n; j < matrixSize; j++)
                        {
                            matrixNumbers[i, j] = (T)Convert.ChangeType((float)(object)matrixNumbers[i, j] - (float)(object)ratio * (float)(object)matrixNumbers[n, j], typeof(T));
                        }
                        B[i] = (T)Convert.ChangeType((float)(object)B[i] - (float)(object)ratio * (float)(object)B[n], typeof(T));
                    }
                    if (typeof(T) == typeof(double))
                    {
                        ratio = (T)Convert.ChangeType((double)(object)matrixNumbers[i, n] / (double)(object)matrixNumbers[n, n], typeof(T));
                        for (int j = n; j < matrixSize; j++)
                        {
                            matrixNumbers[i, j] = (T)Convert.ChangeType((double)(object)matrixNumbers[i, j] - (double)(object)ratio * (double)(object)matrixNumbers[n, j], typeof(T));
                        }
                        B[i] = (T)Convert.ChangeType((double)(object)B[i] - (double)(object)ratio * (double)(object)B[n], typeof(T));
                    }

                }
            }
            result = Calculate(B, index_var);
            return result;
        }

        public T[] HalfChoice(T[] B, T[] X)
        {
            T c;
            T maximum = default(T);
            T[] result = new T[matrixSize];
            Fractions tempVar = new Fractions();
            int row;
            BigInteger NWD = new BigInteger();
            for (int n = 0; n < matrixSize - 1; n++)
            {
                row = n;
                if (typeof(T) == typeof(float))
                {
                    maximum = (T)Convert.ChangeType(Math.Abs((float)(object)matrixNumbers[n, n]), typeof(T));
                }
                else if (typeof(T) == typeof(double))
                {
                    maximum = (T)Convert.ChangeType(Math.Abs((double)(object)matrixNumbers[n, n]), typeof(T));
                }
                else if (typeof(T) == typeof(Fractions))
                {
                    tempVar = (Fractions)(object)matrixNumbers[n, n];
                    tempVar = tempVar.Abs();
                    NWD = tempVar.NWD(tempVar.getNumerator(), tempVar.getDenominator());
                    tempVar.setNumerator(tempVar.getNumerator() / NWD);
                    tempVar.setDenominator(tempVar.getDenominator() / NWD);
                    maximum = (T)Convert.ChangeType(tempVar, typeof(T));
                }
                // sortujemy rowe według kolejności w n-tej kolumnie
                for (int i = n + 1; i < matrixSize; i++)
                {
                    if (typeof(T) == typeof(float))
                    {
                        if ((float)(object)maximum < Math.Abs((float)(object)matrixNumbers[i, n]))
                        {
                            maximum = (T)Convert.ChangeType(Math.Abs((float)(object)matrixNumbers[i, n]), typeof(T));
                            row = i;
                        }
                    }
                    if (typeof(T) == typeof(double))
                    {
                        if ((double)(object)maximum < Math.Abs((double)(object)matrixNumbers[i, n]))
                        {
                            maximum = (T)Convert.ChangeType(Math.Abs((double)(object)matrixNumbers[i, n]), typeof(T));
                            row = i;
                        }
                    }
                    if (typeof(T) == typeof(Fractions))
                    {
                        tempVar = (Fractions)(object)matrixNumbers[i, n];
                        tempVar = tempVar.Abs();
                        NWD = tempVar.NWD(tempVar.getNumerator(), tempVar.getDenominator());
                        tempVar.setNumerator(tempVar.getNumerator() / NWD);
                        tempVar.setDenominator(tempVar.getDenominator() / NWD);
                        if ((Fractions)(object)maximum < tempVar)
                        {
                            tempVar = (Fractions)(object)matrixNumbers[i, n];
                            tempVar = tempVar.Abs();
                            NWD = tempVar.NWD(tempVar.getNumerator(), tempVar.getDenominator());
                            tempVar.setNumerator(tempVar.getNumerator() / NWD);
                            tempVar.setDenominator(tempVar.getDenominator() / NWD);
                            maximum = (T)Convert.ChangeType(tempVar, typeof(T));
                            row = i;
                        }
                    }
                }
                if (row != n)
                {
                    Change(n, row, n);
                    c = B[n];
                    B[n] = B[row];
                    B[row] = c;
                }

                // wykonujemy zerowanie wszystkich rowy poniżej n-tego
                for (int i = n + 1; i < matrixSize; i++)
                {
                    if (typeof(T) == typeof(float))
                    {
                        T ratio = (T)Convert.ChangeType((float)(object)matrixNumbers[i, n] / (float)(object)matrixNumbers[n, n], typeof(T));
                        for (int j = n; j < matrixSize; j++)
                        {
                            matrixNumbers[i, j] = (T)Convert.ChangeType((float)(object)matrixNumbers[i, j] - (float)(object)ratio * (float)(object)matrixNumbers[n, j], typeof(T));
                        }
                        B[i] = (T)Convert.ChangeType((float)(object)B[i] - (float)(object)ratio * (float)(object)B[n], typeof(T));
                    }
                    if (typeof(T) == typeof(double))
                    {
                        T ratio = (T)Convert.ChangeType((double)(object)matrixNumbers[i, n] / (double)(object)matrixNumbers[n, n], typeof(T));
                        for (int j = n; j < matrixSize; j++)
                        {
                            matrixNumbers[i, j] = (T)Convert.ChangeType((double)(object)matrixNumbers[i, j] - (double)(object)ratio * (double)(object)matrixNumbers[n, j], typeof(T));
                        }
                        B[i] = (T)Convert.ChangeType((double)(object)B[i] - (double)(object)ratio * (double)(object)B[n], typeof(T));
                    }
                    if (typeof(T) == typeof(Fractions))
                    {
                        T ratio = (T)Convert.ChangeType((Fractions)(object)matrixNumbers[i, n] / (Fractions)(object)matrixNumbers[n, n], typeof(T));
                        for (int j = n; j < matrixSize; j++)
                        {
                            matrixNumbers[i, j] = (T)Convert.ChangeType((Fractions)(object)matrixNumbers[i, j] - (Fractions)(object)ratio * (Fractions)(object)matrixNumbers[n, j], typeof(T));
                            tempVar = (Fractions)(object)matrixNumbers[i, j];
                            NWD = tempVar.NWD(tempVar.getNumerator(), tempVar.getDenominator());
                            tempVar.setNumerator(tempVar.getNumerator() / NWD);
                            tempVar.setDenominator(tempVar.getDenominator() / NWD);
                            matrixNumbers[i, j] = (T)Convert.ChangeType(tempVar, typeof(T));
                        }
                        B[i] = (T)Convert.ChangeType((Fractions)(object)B[i] - (Fractions)(object)ratio * (Fractions)(object)B[n], typeof(T));
                        tempVar = (Fractions)(object)B[i];
                        NWD = tempVar.NWD(tempVar.getNumerator(), tempVar.getDenominator());
                        tempVar.setNumerator(tempVar.getNumerator() / NWD);
                        tempVar.setDenominator(tempVar.getDenominator() / NWD);
                        B[i] = (T)Convert.ChangeType(tempVar, typeof(T));
                    }
                }
            }
            result = Calculate(B);
            return result;
        }

        public T[] NoChoice(T[] B, T[] X)
        {
            BigInteger NWD = new BigInteger();
            Fractions varTemp = new Fractions();
            T[] result = new T[matrixSize];
            for (int n = 0; n < matrixSize - 1; n++)
            {
                // wykonujemy zerowanie wszystkich rowy poniżej n-tego
                for (int i = n + 1; i < matrixSize; i++)
                {
                    if (typeof(T) == typeof(float))
                    {
                        T ratio = (T)Convert.ChangeType((float)(object)matrixNumbers[i, n] / (float)(object)matrixNumbers[n, n], typeof(T));
                        for (int j = n; j < matrixSize; j++)
                        {
                            matrixNumbers[i, j] = (T)Convert.ChangeType((float)(object)matrixNumbers[i, j] - (float)(object)ratio * (float)(object)matrixNumbers[n, j], typeof(T));
                        }
                        B[i] = (T)Convert.ChangeType((float)(object)B[i] - (float)(object)ratio * (float)(object)B[n], typeof(T));
                    }
                    if (typeof(T) == typeof(double))
                    {
                        T ratio = (T)Convert.ChangeType((double)(object)matrixNumbers[i, n] / (double)(object)matrixNumbers[n, n], typeof(T));
                        for (int j = n; j < matrixSize; j++)
                        {
                            matrixNumbers[i, j] = (T)Convert.ChangeType((double)(object)matrixNumbers[i, j] - (double)(object)ratio * (double)(object)matrixNumbers[n, j], typeof(T));
                        }
                        B[i] = (T)Convert.ChangeType((double)(object)B[i] - (double)(object)ratio * (double)(object)B[n], typeof(T));
                    }
                    if (typeof(T) == typeof(Fractions))
                    {

                        T ratio = (T)Convert.ChangeType((Fractions)(object)matrixNumbers[i, n] / (Fractions)(object)matrixNumbers[n, n], typeof(T));
                        for (int j = n; j < matrixSize; j++)
                        {
                            matrixNumbers[i, j] = (T)Convert.ChangeType((Fractions)(object)matrixNumbers[i, j] - (Fractions)(object)ratio * (Fractions)(object)matrixNumbers[n, j], typeof(T));
                            varTemp = (Fractions)(object)matrixNumbers[i, j];
                            NWD = varTemp.NWD(varTemp.getNumerator(), varTemp.getDenominator());
                            varTemp.setNumerator(varTemp.getNumerator() / NWD);
                            varTemp.setDenominator(varTemp.getDenominator() / NWD);
                            matrixNumbers[i, j] = (T)Convert.ChangeType(varTemp, typeof(T));
                        }
                        B[i] = (T)Convert.ChangeType((Fractions)(object)B[i] - (Fractions)(object)ratio * (Fractions)(object)B[n], typeof(T));
                        varTemp = (Fractions)(object)B[i];
                        NWD = varTemp.NWD(varTemp.getNumerator(), varTemp.getDenominator());
                        varTemp.setNumerator(varTemp.getNumerator() / NWD);
                        varTemp.setDenominator(varTemp.getDenominator() / NWD);
                        B[i] = (T)Convert.ChangeType(varTemp, typeof(T));
                    }
                }
            }
            result = Calculate(B);
            return result;
        }
    }
